{"componentChunkName":"component---src-templates-blog-template-js","path":"/b-login-jwt/","result":{"data":{"cur":{"id":"94cd5b2a-57eb-54b5-b395-ea998a002ac7","html":"<p>본 포스팅에서는 프로젝트에서 채택한 JWT 를 통한 토큰 교환 방식에 대한 생각을 적어보려고 합니다.</p>\n<p>설명하기 앞서, 간단히 JWT에 대해 알아보겠습니다.\n<br> <br></p>\n<h3 id=\"jwt-란\" style=\"position:relative;\"><a href=\"#jwt-%EB%9E%80\" aria-label=\"jwt 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 란?</h3>\n<ul>\n<li>\n<p>header</p>\n<ul>\n<li>typ : JWT (토큰의 종류를 지정. 이 경우 JWT로 고정)</li>\n<li>alg : 암호화 알고리즘</li>\n</ul>\n</li>\n<li>\n<p>payload</p>\n<ul>\n<li>토큰에서 사용할 정보들의 조각인, Claim 이 담겨 있다.</li>\n<li>클레임은 JSON(Key, Value)의 형태로, 다수의 정보를 넣을 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Signature (서명)</p>\n<ul>\n<li>\n<p>서명은 토큰의 유효성 검증을 할 때 사용되는 곳으로, 무결성을 보장한다.</p>\n</li>\n<li>\n<p>헤더 + 페이로드를 BASE64로 인코딩 한 값을 지정된 비밀 키를 이용해 헤더에 적혀있는 alg 으로 암호화한다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>서명은 데이터를 암호화 하는 것은 아니고, 토큰의 데이터가 변조 되지 않았다는 것을 보장합니다. -> 무결성</p>\n<p>해커가 페이로드의 값을 조금이라도 바꾼다면 해시 알고리즘에 의해 Signature는 바뀔 것이고, 서버에서 해당 값을 비교해 데이터가 변조되었는지, 아닌지를 알 수 있습니다.</p>\n<p><br> <br></p>\n<h3 id=\"jwt-생성-방식\" style=\"position:relative;\"><a href=\"#jwt-%EC%83%9D%EC%84%B1-%EB%B0%A9%EC%8B%9D\" aria-label=\"jwt 생성 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 생성 방식</h3>\n<p>다음은 프로젝트에서 엑세스 토큰을 생성하는 JwtUtil 클래스의 일부입니다.</p>\n<img width=\"790\" alt=\"스크린샷 2024-02-02 오전 8 36 07\" src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/56336436/89bfe82d-dae1-4720-9ed5-e3601090c5af\">  \n<br> \n<img width=\"695\" alt=\"스크린샷 2024-02-02 오전 8 36 27\" src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/56336436/cfba84b7-30bb-4a16-adf4-31f3a271758c\">  \n<br> \n<img width=\"788\" alt=\"스크린샷 2024-02-02 오전 8 37 17\" src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/56336436/51fc1ae8-79fb-43d3-a912-eea89883f743\">  \n<p>Secret-Key는 서버에서만 보관하여, 대칭키 암호화 방식을 통해 서명을 생성합니다.</p>\n<p>엑세스 토큰의 Claim에는 멤버 email, provider, refreshTokenId를 넣었습니다.</p>\n<p>리프레시 토큰을 생성하는 방식도 크게 다르지 않습니다.<br>\n<img width=\"790\" alt=\"스크린샷 2024-02-02 오전 8 38 15\" src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/56336436/2e56a933-541e-41ab-b9eb-d609a9005154\"></p>\n<p>리프레시 토큰의 claim 에는 memberEmail 만을 넣었습니다.</p>\n<p>현재 토큰 교환 로직은 다음과 같습니다.</p>\n<p>인증에 성공하면 Access Token, Refresh Token을 발급한다.\nDB 에 Refresh Token을 저장해두고, Access Token만을 클라이언트에게 제공한다.\n엑세스 토큰이 만료된 경우, 토큰의 클레임에 들어있는 refreshTokenId 값으로 DB에서 refresh token을 조회합니다.</p>\n<p>해당 id를 가지는 refresh token이 여전히 유효하다면 access token을 재발급하고, 유효하지 않다면 403 에러를 반환합니다.</p>\n<p>리프레시 토큰이 엑세스 토큰 발급하는 역할을 하는 것입니다.</p>\n<p><br> <br></p>\n<h4 id=\"그렇다면-왜-엑세스-토큰만을-제공하고-리프레시-토큰은-db에만-저장하는지\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%EC%99%9C-%EC%97%91%EC%84%B8%EC%8A%A4-%ED%86%A0%ED%81%B0%EB%A7%8C%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B3%A0-%EB%A6%AC%ED%94%84%EB%A0%88%EC%8B%9C-%ED%86%A0%ED%81%B0%EC%9D%80-db%EC%97%90%EB%A7%8C-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94%EC%A7%80\" aria-label=\"그렇다면 왜 엑세스 토큰만을 제공하고 리프레시 토큰은 db에만 저장하는지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그렇다면 왜 엑세스 토큰만을 제공하고, 리프레시 토큰은 DB에만 저장하는지?</h4>\n<p>JWT로 발급한 엑세스 토큰에는 민감 정보를 담지 말라는 것이 원칙입니다. 이는 해커가 토큰을 탈취해 사용할 수 있기 때문이죠.</p>\n<p>따라서 엑세스 토큰이 탈취되면 사실 손 쓸 방법은 없습니다. 제한시간을 짧게 두어 피해를 줄이는 것이 최선이라고 합니다.</p>\n<p>JWT 방식은 XSS, CSRF 등과 같은 요청을 강제로 발생시키는 공격에 여전히 취약하기도 하며, 따라서 보안을 위해서 이와 같은 방식을 선택했습니다.</p>\n<br>  \n보안 공격과 관련된 간단한 사례를 들어보겠습니다.\n<br> \n<p>CSRF</p>\n<p>사용자 브라우저에 AAA.com 의 인증 정보인, 엑세스 토큰이 쿠키로 저장되어 있습니다.</p>\n<p>이 때 BBB.com 이라는 악성 웹사이트가 img 태그나 하이퍼링크를 통해 서버에 DELETE /userInfo 와 같은 요청을 한다면, 이 요청은 브라우저의 인증 쿠키가 포함된 채로 서버로 전송되고, 서버는 이를 정상적인 요청으로 간주하여 사용자 정보를 삭제해버립니다.</p>\n<br> \nXSS\n<p>AAA.com의 게시판에 해커가 브라우저의 쿠키를 참조하여 자동으로 서버에 요청을 보내는 script 태그를 심어놓았습니다. 웹 페이지가 렌더링 되자마자 해당 코드가 작동해 클라이언트 모르게 서버로 요청이 전송됩니다.</p>\n<br> \n<p>사실 요즘은 위 두 가지 경우는 대부분의 사이트에서 방어가 되어 있긴 합니다.</p>\n<p>CSRF의 경우 referrer 검사, csrf 토큰 검증, double submit 쿠키 검증과 같은 방식으로 방어할 수 있습니다.</p>\n<p>XSS의 경우에는 클라이언트 차원에서 태그 입력 방지(이스케이프 문자열) 같은 방법으로 충분히 대응할 수 있습니다.</p>\n<p>하지만 위와 같은 방식이 100% 방어한다는 보장이 없기 때문에, 해당 공격에 노출되었다는 가정하에 위조된 요청을 어떻게 방어할지에 대한 고민도 필요하다는 생각이 들었습니다.</p>\n<p><br> <br></p>\n<h3 id=\"토큰-교환-전략\" style=\"position:relative;\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B5%90%ED%99%98-%EC%A0%84%EB%9E%B5\" aria-label=\"토큰 교환 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>토큰 교환 전략</h3>\n<br> \n1. Refresh Token은 쿠키에, Access Token은 Response Body로 전달한다.\n<br> \n<p>HttpOnly 쿠키를 활용해 JavaScript 코드가 침투하는 것을 막을 수 있습니다.</p>\n<p>리프레시 토큰을 HTTPOnly 쿠키로 전달한다면, Client-Side JavaScript 가 이 쿠키에 접근할 수 없습니다. 이렇게 하면 XSS 공격을 방지할 수 있습니다. 클라이언트 단에서 로컬 혹은 세션 storage에 값을 저장할 일도 없어, 더 안전하다고 볼 수 있습니다.</p>\n<br> \n<p>이러한 이유들로 인해 어플리케이션에서 Refresh Token을 쿠키에 넣는 경우가 많다고 합니다.</p>\n<p>따라서 이 방식은 서버에서 refresh token을 따로 저장하지 않고도, 토큰의 유효성 검사를 쉽게 할 수 있게 됩니다.</p>\n<br> \n<p>단점으로는 쿠키는 크로스 도메인 제한이 있기 때문에 관리가 복잡해질 수 있고, 쿠키의 크기가 아주 큰 경우에는 네트워크 트래픽 낭비를 야기할 수도 있습니다.</p>\n<p><br> <br>\n2. Refresh Token은 DB에 저장, Access Token만 Response Body 에 전달한다.</p>\n<br> \n<p>이것이 저희 프로젝트에서 채택한 방법입니다.</p>\n<p>리프레시 토큰을 DB단에 저장하고 클라이언트는 Bearer 방식으로 엑세스 토큰을 전달해줍니다.</p>\n<br>  \n<p>엑세스 토큰의 유효기간이 만료되면 Refresh Token 이 유효하다면, 엑세스 토큰을 재발급해줍니다. 클라이언트는 refresh token을 가지고 있지 않습니다.</p>\n<p>하지만 개발 후에, 해당 방식이 바람직한지에 대한 의문이 들었습니다.</p>\n<br>  \n<p>프론트는 엑세스 토큰만 가지고 만료된 엑토큰으로 서버에 접근시, 서버 DB에서 저장된 리프레시 토큰으로 엑세스 토큰을 재발급한다.</p>\n<p>-> ????</p>\n<p>리프레시 토큰을 서버에만 저장하고 프론트에는 주지 않는다면, 그건 엑세스 토큰을 발급해주는 자판기에 불과하다는 생각이 들었습니다.</p>\n<br> \n<p>따라서 이 방식은 적절하지 않다고 생각이 바뀌었습니다.</p>\n<p>한 번 엑세스 토큰이 탈취되면, 해커가 계속해서 엑세스 토큰을 재발급 받을 수 있으니까요. 이는 큰 문제입니다.</p>\n<br> \n<p>따라서 두 토큰 모두 클라이언트에게 발급해 주고, 클라이언트가 유효한 Access Token, Refresh Token을 서버에 제시해야 한다는 생각이 들었습니다.</p>\n<p>프론트에서 리프레시 토큰을 제시해주어야 내가 누구인지, 권한이 있는지를 증명할 수 있을 것입니다.</p>\n<p><br> <br></p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<br> \n따라서 1번 + 2번 방식을 모두 채택하는 것이 더 나은 방법이라고 생각합니다.  \n<br> <br> \nRefreshToken은 쿠키에, AccessToken은 응답으로 제공하고 거기에 DB에 리프레시 토큰을 저장해서 유효성 검사를 하는 것입니다.  \n<p>DB에 리프레시 토큰을 저장하면 문제 발생 시 DB에 있는 리프레시 토큰을 지워서 대처하는 등 서버쪽에서 능동적으로 대처할 수 있는 일이 많을 것이라 생각합니다.</p>\n<br> \n<p>또한 Refresh Token이 사용될 때마다 새로운 access token과 함께 refresh token을 발급하여 이전에 발급된 토큰들을 사용 불가능하게 바꾸는 방법을 추가해도 좋을 것 같습니다. RTR(Refresh Token Rotation)</p>\n <br> \n<p>사실상 완벽한 보안은 없습니다. 인증 방식에는 서로 장단점이 존재하며 상황에 맞게 사용해야 될 것 같다는 것을 느꼈습니다.</p>\n<p>브라우저와 서버 모두 보안에 신경쓰고 대비를 하는 것이 최선일 것 같습니다.</p>\n<p>토큰 교환 전략은 팀원분들과 충분한 회의를 거친 후, 그대로 갈 지 바꿀 지 정할 생각입니다.</p>","excerpt":"본 포스팅에서는 프로젝트에서 채택한 JWT 를 통한 토큰 교환 방식에 대한 생각을 적어보려고 합니다. 설명하기 앞서, 간단히 JWT에 대해 알아보겠습니다.\n  JWT 란? header typ : JWT (토큰의 종류를 지정. 이 경우 JWT로 고정) alg : 암호화 알고리즘 payload 토큰에서 사용할 정보들의 조각인, Claim 이 담겨 있다. 클레임은 JSON(Key, Value)의 형태로, 다수의 정보를 넣을 수 있다. Signature (서명) 서명은 토큰의 유효성 검증을 할 때 사용되는 곳으로, 무결성을 보장한다. 헤더 + 페이로드를 BASE64로 인코딩 한 값을 지정된 비밀 키를 이용해 헤더에 적혀있는 alg 으로 암호화한다. 서명은 데이터를 암호화 하는 것은 아니고, 토큰의 데이터가 변조 되지 않았다는 것을 보장합니다. -> 무결성 해커가 페이로드의 값을 조금이라도 바꾼다면 해시 알고리즘에 의해 Signature는 바뀔 것이고, 서버에서 해당 값을 비교해 데이터가 …","frontmatter":{"date":"February 02, 2024","title":"(JWT) Access Token 과 Refresh Token 저장 및 관리에 대한 고민","categories":"Backend","author":"하정수","emoji":"🍪"},"fields":{"slug":"/b-login-jwt/"}},"next":{"id":"502cb79a-3e27-5248-b6ba-827033c9d1ea","html":"<p>일반적으로 Spring Boot 애플리케이션을 Docker를 이용해 배포할 경우 아래와 같이 작성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> eclipse-temurin:17-jdk-alpine</span>\n<span class=\"token instruction\"><span class=\"token keyword\">VOLUME</span> /tmp</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ARG</span> JAR_FILE</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token variable\">${JAR_FILE}</span> app.jar</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"java\"</span>,<span class=\"token string\">\"-jar\"</span>,<span class=\"token string\">\"/app.jar\"</span>]</span></code></pre></div>\n<p>그러나 위와 같이 Docker 이미지를 만드는 것은 상당히 비효율적이다.</p>\n<p>Docker는 빌드 시 레이어마다 캐시 기능을 사용할 수 있기 때문에 빠른 빌드가 가능하다.</p>\n<p>만약 변경된 부분이 없다면 캐시를 이용해 기존에 빌드했던 레이어를 재사용하기 때문에 속도가 빨라진다.</p>\n<p>하지만 위와 같이 코드를 작성하면 <strong>jar 파일 전체를 빌드하기 때문에 캐시 기능을 사용할 수 없다.</strong></p>\n<p>Dockerfile을 위 구조로 구성하면, Java의 모든 구조가 jar 파일로 묶이기 때문에 layer를 재사용하기 어렵기 때문이다.</p>\n<h2 id=\"기존-방식으로-docker-빌드하기\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-docker-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0\" aria-label=\"기존 방식으로 docker 빌드하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기존 방식으로 Docker 빌드하기</h2>\n<ul>\n<li>\n<p>첫 애플리케이션 빌드 (6.6s)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/13ac357c-a58e-4513-81be-13e4298731bf\" alt=\"image\"></p>\n</li>\n<li>\n<p>코드 수정 후 재빌드 (5.0s)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/659ebd68-1a04-4405-b5f1-44e7d8c03299\" alt=\"image\"></p>\n</li>\n<li>\n<p>이미지 크기는 아래와 같다. (약 700MB)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/438dc94e-045e-42a0-917b-03090dc0054c\" alt=\"image\"></p>\n</li>\n</ul>\n<h2 id=\"새로운-방식으로-docker-빌드하기---layered-jar-사용하기\" style=\"position:relative;\"><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-docker-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0---layered-jar-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"새로운 방식으로 docker 빌드하기   layered jar 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>새로운 방식으로 Docker 빌드하기 - Layered Jar 사용하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> adoptopenjdk:11-jre-hotspot <span class=\"token keyword\">as</span> builder</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> application</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ARG</span> JAR_FILE=build/libs/*.jar</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token variable\">${JAR_FILE}</span> application.jar</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> java -Djarmode=layertools -jar application.jar extract</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> adoptopenjdk:11-jre-hotspot</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> application</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> spring.profiles.active dev</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">builder</span></span> application/dependencies ./</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">builder</span></span> application/spring-boot-loader ./</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">builder</span></span> application/snapshot-dependencies ./</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">builder</span></span> application/application ./</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"java\"</span>, <span class=\"token string\">\"org.springframework.boot.loader.JarLauncher\"</span>]</span></code></pre></div>\n<h3 id=\"layered-jar란\" style=\"position:relative;\"><a href=\"#layered-jar%EB%9E%80\" aria-label=\"layered jar란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layered Jar란?</h3>\n<ul>\n<li>\n<p>Layered Jar란 jar파일을 4개의 영역으로 분리하여 런타임 시 모듈화 및 커스터마이징 할 수 있도록하는 기술이다.</p>\n</li>\n<li>\n<p>Spring Boot는 아래와 같이 jar파일을 4개의 영역으로 만들 수 있다.</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/a5c3c0d4-2e0a-4fab-bbcb-e02cd8436994\" alt=\"image\"></p>\n<p><a href=\"https://velog.io/@ssol_916/Gradle-Layered-Jar-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Dockerbuild-%EC%B5%9C%EC%A0%81%ED%99%94\">https://velog.io/@ssol_916/Gradle-Layered-Jar-그리고-Dockerbuild-최적화</a></p>\n<ul>\n<li>구성은 아래와 같다.\n<ul>\n<li>application: 애플리케이션 소스코드</li>\n<li>snapshot-dependencies: 프로젝트 클래스 경로에 존재하는 스냅샷 종속성 jar 파일</li>\n<li>spring-boot-loader: jar loader와 luncher</li>\n<li>dependencies: 프로젝트 클래스 경로에 존재하는 라이브러리 jar 파일</li>\n</ul>\n</li>\n<li>위로 갈수록 변경이 잦은 부분이며, 아래로 갈수록 변경이 잦지 않다.\n<ul>\n<li>당연하게도 소스 코드가 가장 많이 수정이 이루어지기 때문!</li>\n</ul>\n</li>\n<li>따라서 Docker 캐시 기능을 사용하기 위해, COPY 순서를 역순으로 배치한다.</li>\n</ul>\n</li>\n<li>\n<p>첫 애플리케이션 빌드 (8.1s)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/63cc5eb1-a7da-4437-bf9c-92ee4680ba70\" alt=\"image\"></p>\n</li>\n<li>\n<p>코드 수정 후 재빌드 (6.0s)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/157648fe-9dea-4aa1-8062-494516e810ff\" alt=\"image\"></p>\n</li>\n<li>\n<p>이미지 크기는 아래와 같다 (약 200MB)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/33d3c034-49a6-4e3f-87b4-5b8cbfc8f118\" alt=\"image\"></p>\n</li>\n</ul>\n<h2 id=\"새로운-방식에서-약간-변형하기\" style=\"position:relative;\"><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%B0%A9%EC%8B%9D%EC%97%90%EC%84%9C-%EC%95%BD%EA%B0%84-%EB%B3%80%ED%98%95%ED%95%98%EA%B8%B0\" aria-label=\"새로운 방식에서 약간 변형하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>새로운 방식에서 약간(?) 변형하기</h2>\n<p>시간이 2초정도 단축되었지만 여전히 속도가 느리다는 문제가 발생한다.</p>\n<p>자세히는 알 수 없지만 <strong>jar 파일을 가져오는 과정은 변함이 없기 때문에 느린 것 같다.</strong></p>\n<p>그러나 레이어를 나눌 수 있다는 점을 이용해 아래와 같이 코드를 변경시켰다.</p>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> adoptopenjdk:11-jre-hotspot</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> application</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./dependencies ./</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./spring-boot-loader ./</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./snapshot-dependencies ./</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./application ./</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"java\"</span>, <span class=\"token string\">\"-Dspring.profiles.active=dev\"</span>, <span class=\"token string\">\"-Duser.timezone=Asia/Seoul\"</span>, <span class=\"token string\">\"org.springframework.boot.loader.JarLauncher\"</span>]</span></code></pre></div>\n<p>기존 방식에서 jar 파일을 통째로 COPY하는 과정을 제외하고, 자동화 배포 시 layer를 분리하여 해당 레이어들만 복사하는 방식으로 변형하였다.</p>\n<p>배포 GitHub Actions에는 아래와 같이 jar 파일을 분리하는 명령을 추가했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build Docker &amp; push\n  <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n    cd ./api-module\n    **java -Djarmode=layertools -jar build/libs/${{ secrets.JAR_NAME }} extract**\n    docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}\n    docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPOSITORY }}:server-dev-blue .\n    docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPOSITORY }}:server-dev-green .\n    docker push ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPOSITORY }}:server-dev-blue\n    docker push ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_REPOSITORY }}:server-dev-green</span></code></pre></div>\n<ul>\n<li>\n<p>첫 실행 결과 (4.3s)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/d8b62bb1-5fc3-4bc3-abf4-c309d4668121\" alt=\"image\"></p>\n</li>\n<li>\n<p>코드 수정 후 재빌드 (1.6s)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/df471827-1105-4b61-9de4-464681ec27d5\" alt=\"image\"></p>\n<ul>\n<li>로컬 환경에서 재빌드 시 약 6~8초에서 1초 정도로 단축하였다.</li>\n</ul>\n</li>\n<li>\n<p>빌드 후 이미지 크기 (약 280MB)</p>\n<p><img src=\"https://github.com/devridge-team-project/devridge-team-project.github.io/assets/96467030/9e51a585-8a5e-44aa-aec3-913487065b7c\" alt=\"image\"></p>\n</li>\n</ul>\n<h2 id=\"참고-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\" aria-label=\"참고 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 자료</h2>\n<ul>\n<li><a href=\"https://spring.io/guides/topicals/spring-boot-docker/\">https://spring.io/guides/topicals/spring-boot-docker/</a></li>\n<li><a href=\"https://velog.io/@yyong3519/SpringBoot-%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%B5%9C%EC%A0%81%ED%99%94\">https://velog.io/@yyong3519/SpringBoot-도커-이미지-만들기-최적화</a></li>\n<li><a href=\"https://velog.io/@ssol_916/Gradle-Layered-Jar-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Dockerbuild-%EC%B5%9C%EC%A0%81%ED%99%94\">https://velog.io/@ssol_916/Gradle-Layered-Jar-그리고-Dockerbuild-최적화</a></li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#packaging-executable.configuring.layered-archives\">https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#packaging-executable.configuring.layered-archives</a></li>\n</ul>","frontmatter":{"date":"February 02, 2024","title":"Spring Boot에서 Docker 이미지 최적화하기","categories":"DevOps","author":"유희진","emoji":"☁️"},"fields":{"slug":"/b-docker-refactor/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://flow-team-project.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/b-login-jwt/","nextSlug":"/b-docker-refactor/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}